{"name":"Easter\\On egg","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nprivate FuncXYZ egg = (x,y,z) => sqrt(pow(pow(x, 2) + pow(y, 2) + pow(z, 2) / 2.25d, 3)) - pow(x, 2) - pow(y, 2) - pow(z, 2) / 2.25d;\r\n\r\nprivate SignedDistance sdfBunny = new SignedDistance(\"estbunny.stl\");\r\nprivate SignedDistance sdfHen = new SignedDistance(\"obj_2_ChickenH.stl\");\r\nprivate SignedDistance sdfCock = new SignedDistance(\"obj_1_ChickenC.stl\");\r\n\r\nprivate IneqTree Creature(SignedDistance which, double x, double y, double z, double shift, out Point c)\r\n{\r\n\tvar b = new IneqTree(which.From);\r\n    \r\n  \tvar p = new Point(x, y, z);\r\n  \tProjectToSurface(p, egg);\r\n    \r\n  \tGradient(egg, p, out double nx, out double ny, out double nz);\r\n\r\n    var m = ComputeBasis(nx, ny, nz, 'z');\r\n  \r\n    p.X += shift * nx;\r\n    p.Y += shift * ny;\r\n    p.Z += shift * nz;\r\n  \t\r\n  \tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\tTransform(ref x, ref y, ref z, p, m);\r\n        double a = PI / 2;\t\r\n        double x1 = x * cos(a) - y * sin(a);\r\n        double y1 = x * sin(a) + y * cos(a);\r\n        x = x1; y = y1;\r\n      \tx *= 2.0d; y *= 2.0d; z *= 2.0d;      \t\r\n    });\r\n\t\r\n  \tc = p;\r\n\treturn b;  \r\n}\r\n\r\nprivate IneqTree SmallEgg(double x, double y, double z, char axis, out Point c)\r\n{\r\n\tvar b = new IneqTree(egg);\r\n    \r\n  \tPoint p = new Point(x, y, z);\r\n  \tProjectToSurface(p, egg);\r\n    \r\n  \tGradient(egg, p, out double nx, out double ny, out double nz);\r\n\r\n    var m = ComputeBasis(nx, ny, nz, axis);\r\n  \r\n    p.X += 0.1 * nx;\r\n    p.Y += 0.1 * ny;\r\n    p.Z += 0.1 * nz;\r\n  \t\r\n  \tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\tTransform(ref x, ref y, ref z, p, m);      \t\r\n      \tx *= 8.0d; y *= 8.0d; z *= 8.0d;      \t\r\n    });\r\n\t\r\n\tc = p;\r\n  \treturn b;  \r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n\tvar bunny = Creature(sdfBunny, 1.0d, 0, 0, 0.4, out Point p1);\r\n  \tvar hen = Creature(sdfHen, 0.85, 0, 0.75, 0.4, out Point p2);\r\n  \tvar cock = Creature(sdfCock, 0.85, 0, -0.75, 0.35, out Point p3);\r\n  \r\n\tvar e1 = SmallEgg(0.85, 0.35, 0.75, 'z', out Point ep1);\r\n\tvar e2 = SmallEgg(0.85, -0.45, 0.75, 'x', out Point ep2);\r\n  \tvar e3 = SmallEgg(1.0, -0.35, 0, 'x', out Point ep3);\r\n\tvar e4 = SmallEgg(0.85, -0.5, -0.75, 'z', out Point ep4);  \r\n  \r\n  \tvar subEgg = new IneqTree(egg);\r\n  \tsubEgg.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n      \tx *= 1.15d; y *= 1.15d; z *= 1.15d;      \t\r\n    });\r\n  \r\n  \tvar res = new IneqMesh\r\n    {\r\n        X0 = 0,\r\n        Y0 = -1.0,\r\n        Z0 = -1.5,\r\n        X1 = 2.0,\r\n        Y1 = 1.0,\r\n        Z1 = 1.5,\r\n        D = 0.2d,\r\n        Boxed = true,\r\n        IneqTree =\r\n            (\tegg | \r\n             \tbunny | hen | cock |\r\n            \te1 | e2 | e3 | e4\r\n            ) &\r\n          \t!subEgg\r\n    };\r\n\r\n\tres.PrepareBackgroundMeshBeforeApriory = () => \r\n    {\r\n\t\tres.RefineTetrahedralMeshNearPointRedGreen(new Point[]\r\n\t\t{ \r\n          p1, p2, p3\r\n\t\t}, 0.5d, 1);\r\n\t\tres.RefineTetrahedralMeshNearPointRedGreen(new Point[]\r\n\t\t{ \r\n          ep1, ep2, ep3, ep4\r\n\t\t}, 0.2d, 2);\r\n      \r\n    };\r\n  \r\n  \tres.PrepareBackgroundMesh = () => \r\n    {\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(bunny.Root.ExpressionIndex, 10, 0.03);\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(hen.Root.ExpressionIndex, 10, 0.03);\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(cock.Root.ExpressionIndex, 10, 0.03);\r\n    };\r\n  \r\n  \treturn res;  \r\n}"}