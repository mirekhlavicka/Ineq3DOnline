{"name":"Easter\\On egg","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nprivate FuncXYZ egg = (x,y,z) => sqrt(pow(pow(x, 2) + pow(y, 2) + pow(z, 2) / 2.25d, 3)) - pow(x, 2) - pow(y, 2) - pow(z, 2) / 2.25d;\r\n\r\nprivate SignedDistance estbunny = new SignedDistance(\"bunny.stl\");\r\nprivate SignedDistance hen = new SignedDistance(\"obj_2_ChickenH.stl\");\r\nprivate SignedDistance cock = new SignedDistance(\"obj_1_ChickenC.stl\");\r\n\r\nprivate IneqTree Bunny(double x, double y, double z)\r\n{\r\n\tvar b = new IneqTree(estbunny.From);\r\n    \r\n  \tPoint p = new Point(x, y, z);\r\n  \tProjectToSurface(p, egg);\r\n    \r\n  \tGradient(egg, p, out double nx, out double ny, out double nz);\r\n\r\n    var m = ComputeBasis(nx, ny, nz, 'z');\r\n  \r\n    p.X += 0.4 * nx;\r\n    p.Y += 0.4 * ny;\r\n    p.Z += 0.4 * nz;\r\n  \t\r\n  \tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\tTransform(ref x, ref y, ref z, p, m);\r\n        double a = PI;\t\r\n        double x1 = x * cos(a) - y * sin(a);\r\n        double y1 = x * sin(a) + y * cos(a);\r\n        x = x1; y = y1;\r\n      \tx *= 2.0d; y *= 2.0d; z *= 2.0d;      \t\r\n    });\r\n\t\r\n\treturn b;  \r\n}\r\n\r\nprivate IneqTree Hen(double x, double y, double z)\r\n{\r\n  \t/*var e = new IneqTree(egg);\r\n  \r\n\te.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\ty -=1.0d; z += 0.5;\r\n      \tx *= 3; y *= 3; z *= 3;      \t\r\n    });*/  \t\r\n  \r\n\tvar b = new IneqTree(hen.From);// | e;  \r\n    \r\n  \tPoint p = new Point(x, y, z);\r\n  \tProjectToSurface(p, egg);\r\n    \r\n  \tGradient(egg, p, out double nx, out double ny, out double nz);\r\n\r\n    var m = ComputeBasis(nx, ny, nz, 'z');\r\n  \r\n    p.X += 0.4 * nx;\r\n    p.Y += 0.4 * ny;\r\n    p.Z += 0.4 * nz;\r\n  \t\r\n  \tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\tTransform(ref x, ref y, ref z, p, m);\r\n        double a = PI / 2;\t\r\n        double x1 = x * cos(a) - y * sin(a);\r\n        double y1 = x * sin(a) + y * cos(a);\r\n        x = x1; y = y1;\r\n      \tx *= 2.0d; y *= 2.0d; z *= 2.0d;      \t\r\n    });\r\n\t\r\n\treturn b;  \r\n}\r\n\r\nprivate IneqTree Cock(double x, double y, double z)\r\n{\r\n\tvar b = new IneqTree(cock.From);\r\n    \r\n  \tPoint p = new Point(x, y, z);\r\n  \tProjectToSurface(p, egg);\r\n    \r\n  \tGradient(egg, p, out double nx, out double ny, out double nz);\r\n\r\n    var m = ComputeBasis(nx, ny, nz, 'z');\r\n  \r\n    p.X += 0.4 * nx;\r\n    p.Y += 0.4 * ny;\r\n    p.Z += 0.4 * nz;\r\n  \t\r\n  \tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\tTransform(ref x, ref y, ref z, p, m);\r\n        double a = PI / 2;\t\r\n        double x1 = x * cos(a) - y * sin(a);\r\n        double y1 = x * sin(a) + y * cos(a);\r\n        x = x1; y = y1;\r\n      \tx *= 2.0d; y *= 2.0d; z *= 2.0d;      \t\r\n    });\r\n\t\r\n\treturn b;  \r\n}\r\n\r\nprivate IneqTree Egg(double x, double y, double z, char axis)\r\n{\r\n\tvar b = new IneqTree(egg);\r\n    \r\n  \tPoint p = new Point(x, y, z);\r\n  \tProjectToSurface(p, egg);\r\n    \r\n  \tGradient(egg, p, out double nx, out double ny, out double nz);\r\n\r\n    var m = ComputeBasis(nx, ny, nz, axis);\r\n  \r\n    p.X += 0.1 * nx;\r\n    p.Y += 0.1 * ny;\r\n    p.Z += 0.1 * nz;\r\n  \t\r\n  \tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\tTransform(ref x, ref y, ref z, p, m);      \t\r\n      \tx *= 8.0d; y *= 8.0d; z *= 8.0d;      \t\r\n    });\r\n\t\r\n\treturn b;  \r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n\tvar bunny = Bunny(1.0d, 0, 0);\r\n  \tvar hen = Hen(0.85, 0, 0.75);\r\n  \tvar cock = Cock(0.85, 0, -0.75);\r\n\t//var b2 = Creature(0.85d, 0, 0.75d);\r\n  \t//var b3 = Creature(0.85d, 0, -0.75d);\r\n  \r\n  \t/*var subEgg = new IneqTree(egg);\r\n  \tsubEgg.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n      \tx *= 1.15d; y *= 1.15d; z *= 1.15d;      \t\r\n    });*/\r\n  \r\n  \tvar res = new IneqMesh\r\n    {\r\n        X0 = 0,\r\n        Y0 = -1.0,\r\n        Z0 = -1.5,\r\n        X1 = 2.0,\r\n        Y1 = 1.0,\r\n        Z1 = 1.5,\r\n        D = 0.2d,\r\n        Boxed = true,\r\n        IneqTree =\r\n            (egg | bunny | hen | cock |\r\n            \tEgg(0.85, 0.35, 0.75, 'z')\r\n            ) //&\r\n          \t//!subEgg\r\n    };\r\n\r\n\tres.PrepareBackgroundMeshBeforeApriory = () => \r\n    {\r\n\t\tres.RefineTetrahedralMeshNearPointRedGreen(new Point[]\r\n\t\t{ \r\n          new Point(1.4,0,0),\r\n          new Point(0.85 + 0.4, 0, 0.75),\r\n          new Point(0.85 + 0.4, 0, -0.75),\r\n          new Point(0.85 + 0.4, 0.35, 0.75)\r\n\t\t}, 0.45d, 2);\r\n      \r\n    };\r\n  \r\n  \tres.PrepareBackgroundMesh = () => \r\n    {\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(bunny.Root.ExpressionIndex, 15, 0.03);\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(hen.Root.ExpressionIndex, 10, 0.05);\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(cock.Root.ExpressionIndex, 10, 0.05);\r\n    };\r\n  \r\n  \treturn res;  \r\n}\r\n"}