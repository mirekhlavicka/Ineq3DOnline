{"name":"Easter\\Cock hen bunny","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nprivate SignedDistance henne = new SignedDistance(\"Henne.stl\");\r\nprivate SignedDistance hahn = new SignedDistance(\"Hahn.stl\");\r\nprivate SignedDistance estbunny = new SignedDistance(\"Estbunny.stl\");\r\n\r\npublic IneqTree Creature(SignedDistance which, double x, double y, double z)\r\n{\r\n    Point p = new Point(x, y, z);\r\n  \r\n  \tdouble n = sqrt(x*x + y*y +z*z);\r\n  \tdouble nx = x/n;\r\n  \tdouble ny = y/n;\r\n  \tdouble nz = z/n;\r\n  \r\n    p.X += 0.3 * nx;\r\n    p.Y += 0.3 * ny;\r\n    p.Z += 0.3 * nz;\r\n\r\n    var m = ComputeBasis(nx, ny, nz, 'z');\r\n\r\n    IneqTree res = new IneqTree((x, y, z) => which.From(x,y,z));\r\n  \r\n  \tres.Transform(delegate(ref double x, ref double y, ref double z) \r\n    {\r\n\t\tTransform(ref x, ref y, ref z, p, m);\r\n\r\n      \tif(which == hahn)\r\n        {\r\n\t\t\tdouble a = PI / 2;\t\r\n          \tdouble x1 = x * cos(a) - y * sin(a);\r\n          \tdouble y1 = x * sin(a) + y * cos(a);\r\n          \tx = x1; y = y1;\r\n        }\r\n      \r\n      \tx *= 3.0d; y *= 3.0d; z *= 3.0d;      \t\r\n    });  \r\n    return res;\r\n}\r\n\r\npublic IneqTree Egg(double x, double y, double z, char axis)\r\n{\r\n    IneqTree res = new IneqTree();\r\n\r\n    Point p = new Point(x, y, z);\r\n\r\n  \tdouble n = sqrt(x*x + y*y + z*z);\r\n  \tdouble nx = x/n;\r\n  \tdouble ny = y/n;\r\n  \tdouble nz = z/n;\r\n\r\n    p.X += 0.08 * nx;\r\n    p.Y += 0.08 * ny;\r\n    p.Z += 0.08 * nz;\r\n\r\n\r\n    var m = ComputeBasis(nx, ny, nz, axis);\r\n\r\n    res = res | new IneqTree((x, y, z) =>\r\n    {\r\n        Transform(ref x, ref y, ref z, p, m);\r\n\r\n        x = x * 10;\r\n        y = y * 10;\r\n        z = z * 10;\r\n\r\n        return sqrt(pow(pow(x, 2) + pow(y, 2) + pow(z, 2) / 2.25d, 3)) - pow(x, 2) - pow(y, 2) - pow(z, 2) / 2.25d;\r\n    });\r\n    return res;\r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n\tdouble n = 1.0d/sqrt(2.0d);\r\n  \r\n    var he = Creature(henne, 0.75d, 0, 0);\r\n    var ha = Creature(hahn, 0, 0.75d, 0);\r\n    var es = Creature(estbunny, 0.75d * n, 0.75d  * n, 0);\r\n\t\r\n  \tvar res = new IneqMesh\r\n    {\r\n        X0 = -1.0,\r\n        Y0 = -1.0,\r\n        Z0 = -1.0,\r\n        X1 = 1.5,\r\n        Y1 = 1.5,\r\n        Z1 = 1.0,\r\n        D = 0.2d,\r\n        Boxed = true,\r\n        IneqTree =\r\n\t\t(\r\n          Ball(0, 0, 0, 0.75d) | \r\n          he |\r\n          ha |\r\n          es |\r\n          Egg(0.75d*cos(0.3d), 0, 0.75d*sin(0.3d), 'z') |\r\n          Egg(0.75d*cos(-0.3d), 0, 0.75d*sin(-0.3d), 'x') |\r\n          Egg(0, 0.75d*cos(-0.3d), 0.75d*sin(-0.3d), 'x') |\r\n          Egg(cos(-0.3d) * 0.75d * n, cos(-0.3d) * 0.75d * n, 0.75d * sin(-0.3d), 'z')\r\n\t\t) &\r\n\t\t(# -x-y) &\r\n\t\t!Ball(0, 0, 0, 0.6d)          \r\n          \r\n      };\r\n  \r\n\tres.PrepareBackgroundMeshBeforeApriory = () => \r\n    {\r\n\t\tres.RefineTetrahedralMeshNearPointRedGreen(new Point[]\r\n\t\t{ \r\n          new Point(0.75d + 0.3d, 0, 0),\r\n          new Point(0, 0.75d + 0.3d, 0),\r\n          new Point(0.75d  * n + 0.3*n, 0.75d  * n + 0.3*n, 0),\r\n          new Point(0.75d*cos(0.3d), 0, 0.75d*sin(0.3d)),\r\n          new Point(0.75d*cos(-0.3d), 0, 0.75d*sin(-0.3d)),\r\n          new Point(0, 0.75d*cos(-0.3d), 0.75d*sin(-0.3d)),\r\n\t\t  new Point(cos(-0.3d) * 0.75d * n, cos(-0.3d) * 0.75d * n, 0.75d * sin(-0.3d))            \r\n\t\t}, 0.4d, 2);\r\n      \r\n    };\r\n  \r\n  \tres.PrepareBackgroundMesh = () => \r\n    {\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(ha.Root.ExpressionIndex, 5, 0.03);\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(he.Root.ExpressionIndex, 5, 0.03);\r\n      \tres.RefineTetrahedralMeshByTetrahedrons(es.Root.ExpressionIndex, 10, 0.03);\r\n    };\r\n  \r\n  \treturn res;    \r\n}"}