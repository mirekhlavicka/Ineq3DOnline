{"name":"Helix and balls","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n    return new IneqMesh\r\n    {\r\n        X0 = -1.8,\r\n        Y0 = -1.8,\r\n        Z0 = 0.0,\r\n        X1 = 1.8,\r\n        Y1 = 1.8,\r\n        Z1 = 8.0,\r\n        D = 0.2d,\r\n        Boxed = true,\r\n        IneqTree =\r\n          ((IneqTree)((x, y, z) => HelixDistance.Squared(x,y,z, 1, 0.4) - 0.5d)) |\r\n          ((x, y, z) => x*x + y*y + z*z -1 ) |\r\n          ((x, y, z) => x*x + y*y + (z-4)*(z-4) -1 )\r\n      };\r\n}\r\n\r\nprivate static class HelixDistance\r\n{\r\n    public static double Squared(double x, double y, double z, double r = 1, double c = 1, double tolerance = 1e-5, int maxIterations = 100)\r\n    {\r\n        double t = z / c;\r\n        double t0 = z / c -  1 * Math.PI; \r\n\r\n        while (t0 < z / c + 1 * Math.PI)\r\n        {\r\n            if(SquaredDistance(x, y, z, r, c, t0) < SquaredDistance(x, y, z, r, c, t)) \r\n            { \r\n                t = t0;\r\n            }\r\n            t0 += 0.1;\r\n        }\r\n\r\n        int iteration = 0;\r\n\r\n\r\n        while (iteration < maxIterations)\r\n        {\r\n            double fd = FirstDerivative(x, y, z, r, c, t);\r\n            double sd = SecondDerivative(x, y, z, r, c, t);\r\n\r\n            if (Math.Abs(sd) < 1e-8)\r\n            {\r\n                break;\r\n                //throw new Exception(\"Second derivative too small, Newton's method failed.\");\r\n            }\r\n\r\n            double tNext = t - fd / sd;\r\n\r\n            if (Math.Abs(tNext - t) < tolerance)\r\n            {\r\n                t = tNext;\r\n                break;\r\n            }\r\n\r\n            t = tNext;\r\n            iteration++;\r\n        }\r\n\r\n        /*if (iteration == maxIterations)\r\n        {\r\n            throw new Exception(\"Newton's method did not converge within the maximum number of iterations.\");\r\n        }*/\r\n\r\n        return SquaredDistance(x, y, z, r, c, t);\r\n    }\r\n\r\n    private static double SquaredDistance(double x, double y, double z, double r, double c, double t)\r\n    {\r\n        double helixX = r * Math.Cos(t);\r\n        double helixY = r * Math.Sin(t);\r\n        double helixZ = c * t;\r\n\r\n        double dx = x - helixX;\r\n        double dy = y - helixY;\r\n        double dz = z - helixZ;\r\n\r\n        return dx * dx + dy * dy + dz * dz;\r\n    }\r\n\r\n    private static double FirstDerivative(double x, double y, double z, double r, double c, double t)\r\n    {\r\n        return r * x * Math.Sin(t) - r * y * Math.Cos(t) - z + c * t;\r\n    }\r\n\r\n    private static double SecondDerivative(double x, double y, double z, double r, double c, double t)\r\n    {\r\n        return r * x * Math.Cos(t) + r * y * Math.Sin(t) + c;\r\n    }\r\n}\r\n"}