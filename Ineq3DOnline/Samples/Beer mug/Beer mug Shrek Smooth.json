{"name":"Beer mug\\Beer mug Shrek Smooth","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\npublic IneqTree TorusPQ(double x0, double y0, double z0, double r, double R)\r\n{\r\n\r\n    return new IneqTree((x, y, z) =>\r\n    {\r\n\t\tdouble p, q;\r\n\r\n      \tx = x - x0;\r\n        y = y - y0;\r\n        z = z - z0;      \r\n\r\n      \tp = z < 0 ? 2 : 6;\r\n      \tq = 8;\r\n      \r\n      \tdouble pn = pow(pow(abs(x), p) + pow(abs(z), p), 1.0d/p);\r\n      \r\n      \tdouble sx =  R * x / pn;\r\n      \tdouble sz =  R * z / pn;\r\n\r\n\t\tdouble v = sqrt((x-sx)*(x-sx) + (z-sz)*(z-sz));\r\n      \r\n      \treturn pow(pow(y, q) + pow(2*v, q), 1.0/q) - r;\r\n\r\n    });\r\n}\r\n\r\npublic IneqTree Balls(int count, double r/*, out List<Point> points*/)\r\n{\r\n    IneqTree res = new IneqTree();\r\n  \t//points = new List<Point>();\r\n\tfor (int j = -1; j < 2; j++)\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n\t\tdouble x = r*cos(i * 2 * PI / count + abs(j) * PI / count);\r\n      \tdouble y = r*sin(i * 2 * PI / count + abs(j) * PI / count);\r\n      \r\n\t\tvar b = Ball(x,y,0.75 * j,0.2);\r\n      \tres = res | b;\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\npublic IneqTree Shrek()\r\n{\r\n  \tvar sdf = new SignedDistance(\"Shrek Head.stl\");\r\n\t//var f = sdf.From;\r\n  \tvar b = (# sdf.From(x, y, z) - 0.05) ;\r\n  \r\n  \tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n\t{\r\n\t\tdouble s = 2;\r\n      \ty +=0.67;\r\n      \r\n        double a = -PI/2;\r\n\r\n      \tdouble x1 = x * cos(a) - y * sin(a);\r\n        double y1 =x * sin(a) + y * cos(a);\r\n      \tx = x1; y = y1;      \r\n\r\n      \r\n        a = -PI/4 - 0.2;\r\n\r\n      \tx1 = x * cos(a) - z * sin(a);\r\n        double z1 =x * sin(a) + z * cos(a);\r\n      \tx = x1; z = z1;      \r\n      \r\n      \r\n      \tx *= s; y *= s; z *= s; \r\n    });  \r\n\t\r\n  \treturn b;\r\n}\r\n\r\npublic  IneqTree Mug()\r\n{\r\n  \tvar c1 = Shrek() | Cylinder(0, 0 ,-1, 0, 0 ,1, 0.7, 1) & !Balls(8, 0.87);\r\n  \tvar c2 = Cylinder(0, 0 ,-0.9, 0, 0 ,1.1, 0.6, 1);\r\n  \r\n  \tc1.Transform(delegate(ref double x, ref double y, ref double z) \r\n\t{\r\n\t\tdouble s = 1 + 0.75d * (cos(z-0.2) - cos(1.0));      \r\n      \tx /= s; y /= s; \r\n    });\r\n\r\n  \tc2.Transform(delegate(ref double x, ref double y, ref double z) \r\n\t{\r\n\t\tdouble s = 1 +  + 0.75d * (cos(z-0.2) - cos(1.0));      \r\n      \tx /= s; y /= s; \r\n    });\r\n  \r\n  \tvar res = (TorusPQ(0.73, 0, 0, 0.15, 0.6) | c1) & !c2;\r\n\r\n\treturn res;\t  \r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n    var res = new IneqMesh\r\n    {\r\n        X0 = -1.1,\r\n        Y0 = -1.5,\r\n        Z0 = -1.1,\r\n        X1 = 1.9,\r\n        Y1 = 1.1,\r\n        Z1 = 1.1,\r\n        D = 0.1d,\r\n        Boxed = false,\r\n        IneqTree =  Mug().ToFunc(0.02)\r\n      };\r\n  \r\n\tres.PrepareBackgroundMeshBeforeApriory = () => \r\n    {\r\n        for (int i = 0; i < 3; i++)\r\n        {\r\n      \t\tres.RefineTetrahedralMesh(0, 2, 0.05, false);\r\n          \t//res.RefineTetrahedralMesh(1, 2, 0.05, false);\r\n      \t\tres.JiggleBackgroundMash(3);\r\n        }     \r\n    };\r\n  \r\n\treturn res;  \r\n}\r\n"}