{"name":"Anuloids on anuloid","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\nprivate IneqTree IneqTreeAnuloid(double x0, double y0, double z0, double r, double R, double nx, double ny, double nz, bool outside = false)\r\n{\r\n\r\n    return new IneqTree((x, y, z) => \r\n    {\r\n        x = x - x0;\r\n        y = y - y0;\r\n        z = z - z0;\r\n        double vp = x * nx + y * ny + z * nz;\r\n        double v1 = x - vp * nx;\r\n        double v2 = y - vp * ny;\r\n        double v3 = z - vp * nz;\r\n        double v = Math.Sqrt(v1 * v1 + v2 * v2 + v3 * v3);\r\n\r\n        if (outside)\r\n        {\r\n            return -Math.Pow(R - v, 2) - vp * vp + r * r;\r\n        }\r\n        else\r\n        {\r\n            return Math.Pow(R - v, 2) + vp * vp - r * r;\r\n        }\r\n    });\r\n}\r\n\r\nprivate IneqTree IneqTreeAnuloids1(int count, double RR, double R,double r)\r\n{\r\n    IneqTree res = new IneqTree((x, y, z) => 1);\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        double rx = Math.Cos(i * 2 * Math.PI / count);\r\n        double ry = Math.Sin(i * 2 * Math.PI / count);\r\n\r\n\r\n        double x0 = RR* rx;\r\n        double y0 = RR * ry;\r\n\r\n        res = res | IneqTreeAnuloid(x0, y0, 0, r, R, -ry, rx, 0);\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n\tvar p = 5d;\r\n  \tvar ball = new IneqTree((x, y, z) => Math.Pow(Math.Abs(x),p) + Math.Pow(Math.Abs(y),p)  + Math.Pow(Math.Abs(z),p) - Math.Pow(0.7d,p));\r\n  \r\n    return new IneqMesh\r\n    {\r\n        X0 = -1.0,\r\n        Y0 = -1.0,\r\n        Z0 = -0.5,\r\n        X1 = 1.0,\r\n        Y1 = 1.0,\r\n        Z1 = 0.5,\r\n        D = 0.075d,\r\n        Boxed = false,\r\n        IneqTree = IneqTreeAnuloids1(8, 0.7d, 0.2d, 0.1d)\r\n          | IneqTreeAnuloid(0, 0, 0, 0.15d, 0.7d, 0, 0, 1)\r\n      };\r\n}\r\n"}