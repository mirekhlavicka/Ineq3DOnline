{"name":"3D models\\Henne plus eggs","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nprivate SignedDistance sdf = new SignedDistance(\"Henne.stl\");\r\n\r\npublic IneqTree BackEgg()\r\n{\r\n    IneqTree res = new IneqTree();\r\n\r\n    Point p = new Point(-0.35d, 1.0d, -0.4d);\r\n\r\n    sdf.Project(p);\r\n    Gradient(sdf.From, p, out double nx, out double ny, out double nz);\r\n\r\n    p.X += 0.05 * nx;\r\n    p.Y += 0.05 * ny;\r\n    p.Z += 0.05 * nz;\r\n\r\n\r\n    var m = ComputeBasis(nx, ny, nz, 'z');\r\n\r\n    res = res | new IneqTree((x, y, z) =>\r\n    {\r\n        Transform(ref x, ref y, ref z, p, m);\r\n\r\n        x = x * 10;\r\n        y = y * 10;\r\n        z = z * 10;\r\n\r\n        return sqrt(pow(pow(x, 2) + pow(y, 2) + pow(z, 2) / 2.25d, 3)) - pow(x, 2) - pow(y, 2) - pow(z, 2) / 2.25d;\r\n    });\r\n    return res;\r\n}\r\n\r\npublic IneqTree Eggs(int count)\r\n{\r\n    IneqTree res = new IneqTree();\r\n    Random random = new Random();\r\n    List<Point> points = new List<Point>();\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        Point p = new Point(\r\n                random.NextDouble() * 1.6d - 0.8d,\r\n                random.NextDouble() * 1.1d - 0.8d,\r\n                random.NextDouble() * 0.1d - 0.7d);\r\n\r\n        if (abs(sdf.From(p.X, p.Y, p.Z)) < 0.1d)\r\n        {\r\n            sdf.Project(p);\r\n            if (!points.Any(p1 => p1.Distance(p) < 2.3d * 0.1d))\r\n            {\r\n                Gradient(sdf.From, p, out double nx, out double ny, out double nz);\r\n\r\n                p.X += 0.05 * nx;\r\n                p.Y += 0.05 * ny;\r\n                p.Z += 0.05 * nz;\r\n\r\n                points.Add(p);\r\n\r\n                var m = ComputeBasis(nx, ny, nz, 'x');\r\n\r\n                res = res | new IneqTree((x, y, z) =>\r\n                {\r\n                    Transform(ref x, ref y, ref z, p, m);\r\n\r\n                    x = x * 10;\r\n                    y = y * 10;\r\n                    z = z * 10;\r\n\r\n                    return sqrt(pow(pow(x, 2) + pow(y, 2) + pow(z, 2) / 2.25d, 3)) - pow(x, 2) - pow(y, 2) - pow(z, 2) / 2.25d;\r\n                });\r\n            }\r\n        }\r\n    }\r\n    return res;\r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n    Func<double, double, double, double> f = sdf.From;\r\n    var b = new IneqTree(f);\r\n\r\n    var res = new IneqMesh\r\n    {\r\n        X0 = -1,\r\n        Y0 = -1,\r\n        Z0 = -1,\r\n        X1 = 1,\r\n        Y1 = 1,\r\n        Z1 = 1,\r\n        D = 0.05,\r\n        Boxed = true,\r\n        IneqTree =\r\n            (b | BackEgg() | Eggs(600)) & !new IneqTree((x, y, z) => z + 0.95)\r\n    };\r\n    res.ProjectToSurfaceSpec[f] = sdf.Project;\r\n    res.PrepareBackgroundMesh = () => res.RefineTetrahedralMeshByTetrahedrons(0, 10, 0.1);\r\n\r\n    return res;\r\n}"}