{"name":"Ball\\Dodecahedron Balls","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nstatic void Normalize(double[,] verts)\r\n{\r\n  for (int i = 0; i < verts.GetLength(0); i++)\r\n  {\r\n    double x = verts[i, 0];\r\n    double y = verts[i, 1];\r\n    double z = verts[i, 2];\r\n    double len = Math.Sqrt(x * x + y * y + z * z);\r\n    verts[i, 0] /= len;\r\n    verts[i, 1] /= len;\r\n    verts[i, 2] /= len;\r\n  }\r\n}\r\n\r\nstatic int[,] BuildEdges(int[,] faces)\r\n{\r\n  var set = new HashSet<(int, int)>();\r\n\r\n  int faceCount = faces.GetLength(0);\r\n  int vertsPerFace = faces.GetLength(1);\r\n\r\n  for (int i = 0; i < faceCount; i++)\r\n  {\r\n    for (int j = 0; j < vertsPerFace; j++)\r\n    {\r\n      int a = faces[i, j];\r\n      int b = faces[i, (j + 1) % vertsPerFace]; // wrap around\r\n      AddEdge(set, a, b);\r\n    }\r\n  }\r\n\r\n  int[,] edges = new int[set.Count, 2];\r\n  int idx = 0;\r\n  foreach (var e in set)\r\n  {\r\n    edges[idx, 0] = e.Item1;\r\n    edges[idx, 1] = e.Item2;\r\n    idx++;\r\n  }\r\n  return edges;\r\n}\r\n\r\nstatic void AddEdge(HashSet<(int, int)> set, int i, int j)\r\n{\r\n  if (i > j) (i, j) = (j, i); // keep ordering consistent\r\n  set.Add((i, j));\r\n}\r\n\r\nprivate IneqTree Balls()\r\n{\r\n\tvar res = new IneqTree();\t\r\n\r\n    var vertices = new double[,]\r\n    {\r\n        { -0.577350269190,  0.577350269190,  0.577350269190 },\r\n        {  0.000000000000,  0.934172358963,  0.356822089773 },\r\n        {  0.000000000000,  0.934172358963, -0.356822089773 },\r\n        { -0.577350269190,  0.577350269190, -0.577350269190 },\r\n        { -0.934172358963,  0.356822089773,  0.000000000000 },\r\n        {  0.577350269190,  0.577350269190,  0.577350269190 },\r\n        { -0.356822089773,  0.000000000000,  0.934172358963 },\r\n        { -0.934172358963, -0.356822089773,  0.000000000000 },\r\n        { -0.356822089773,  0.000000000000, -0.934172358963 },\r\n        {  0.577350269190,  0.577350269190, -0.577350269190 },\r\n        {  0.577350269190, -0.577350269190,  0.577350269190 },\r\n        {  0.000000000000, -0.934172358963,  0.356822089773 },\r\n        {  0.000000000000, -0.934172358963, -0.356822089773 },\r\n        {  0.577350269190, -0.577350269190, -0.577350269190 },\r\n        {  0.934172358963, -0.356822089773,  0.000000000000 },\r\n        {  0.356822089773,  0.000000000000,  0.934172358963 },\r\n        { -0.577350269190, -0.577350269190,  0.577350269190 },\r\n        { -0.577350269190, -0.577350269190, -0.577350269190 },\r\n        {  0.356822089773,  0.000000000000, -0.934172358963 },\r\n        {  0.934172358963,  0.356822089773,  0.000000000000 }\r\n    };\r\n\r\n    // 12 pentagonal faces (each row: 5 vertex indices into Vertices[,] above)\r\n    // The faces are ordered so face i corresponds to the pentagon around the i-th icosahedron vertex\r\n    var faces = new int[,]\r\n    {\r\n        {  3,  4,  0,  1,  2 },\r\n        {  2,  1,  5, 19,  9 },\r\n        { 16,  7, 17, 12, 11 },\r\n        { 11, 12, 13, 14, 10 },\r\n        {  6, 16, 11, 10, 15 },\r\n        {  0,  6, 15,  5,  1 },\r\n        { 17,  8, 18, 13, 12 },\r\n        {  8,  3,  2,  9, 18 },\r\n        { 13, 18,  9, 19, 14 },\r\n        {  5, 15, 10, 14, 19 },\r\n        {  7,  4,  3,  8, 17 },\r\n        {  4,  7, 16,  6,  0 }\r\n    };\r\n\r\n    // 30 unique edges (unordered pairs of vertex indices)\r\n    var edges = new int[,]\r\n    {\r\n        { 0,  1 }, { 0,  4 }, { 0,  6 }, { 1,  2 }, { 1,  5 },\r\n        { 2,  3 }, { 2,  9 }, { 3,  4 }, { 3,  8 }, { 4,  7 },\r\n        { 5, 15 }, { 5, 19 }, { 6, 15 }, { 6, 16 }, { 7, 16 },\r\n        { 7, 17 }, { 8, 17 }, { 8, 18 }, { 9, 18 }, { 9, 19 },\r\n        {10, 11 }, {10, 14 }, {10, 15 }, {11, 12 }, {11, 16 },\r\n        {12, 13 }, {12, 17 }, {13, 14 }, {13, 18 }, {14, 19 }\r\n    };\r\n  \r\n  \r\n  \r\n  \r\n    // print check\r\n    for (int i = 0; i < vertices.GetLength(0); i++)\r\n    {\r\n\t\tres = res | Ball(vertices[i,0], vertices[i,1], vertices[i,2], 0.25)      ;\r\n    }\r\n  \r\n  \t//var edges = BuildEdges(faces);\r\n  \r\n  \tfor (int i = 0; i < edges.GetLength(0); i++)\r\n    {\r\n\t\tvar v1 = edges[i, 0];\r\n      \tvar v2 = edges[i, 1];\r\n      \tres = res | Cylinder(vertices[v1,0], vertices[v1,1], vertices[v1,2], vertices[v2,0], vertices[v2,1], vertices[v2,2], 0.1, 0.2);\r\n    }\r\n  \r\n   \treturn res;\r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n    return new IneqMesh\r\n    {\r\n        X0 = -1.8,\r\n        Y0 = -1.8,\r\n        Z0 = -1.8,\r\n        X1 = 1.8,\r\n        Y1 = 1.8,\r\n        Z1 = 1.8,\r\n        D = 0.1d,\r\n        Boxed = true,\r\n        IneqTree = Balls()//.ToFunc(0.08)// & !(Ball(0,0,0,1))\r\n\t};\r\n}\r\n"}