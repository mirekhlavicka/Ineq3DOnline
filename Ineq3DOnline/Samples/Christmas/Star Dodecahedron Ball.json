{"name":"Christmas\\Star Dodecahedron Ball","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nstruct Vec3\r\n{\r\n    public double X, Y, Z;\r\n\r\n    public Vec3(double x, double y, double z)\r\n    {\r\n        X = x; Y = y; Z = z;\r\n    }\r\n\r\n    public static Vec3 Cross(Vec3 a, Vec3 b)\r\n    {\r\n        return new Vec3(\r\n            a.Y * b.Z - a.Z * b.Y,\r\n            a.Z * b.X - a.X * b.Z,\r\n            a.X * b.Y - a.Y * b.X\r\n        );\r\n    }\r\n\r\n    public double Length()\r\n    {\r\n        return Math.Sqrt(X * X + Y * Y + Z * Z);\r\n    }\r\n\r\n    public Vec3 Normalize()\r\n    {\r\n        double len = Length();\r\n        return new Vec3(X / len, Y / len, Z / len);\r\n    }\r\n}\r\n\r\nprivate IneqTree StarBall()\r\n{\r\n\tIneqTree res = /*Ineq3DOnline.PlatonicSolids.Polyhedron.CreateDodecahedron(1).ToIneqTree()\r\n      & !Ineq3DOnline.PlatonicSolids.Polyhedron.CreateDodecahedron(0.95).ToIneqTree();*/\r\n      Ball(0,0,0,1) & !Ball(0,0,0,0.95);\r\n\r\n  \tvar pol = Ineq3DOnline.PlatonicSolids.Polyhedron.CreateDodecahedron(1);\r\n\tdouble a = (PI - acos(-sqrt(5)/5))/2;  \r\n  \r\n  \tforeach (var face in pol.Faces.Where((item, index) => index != 4)/*.Take(1)*/)\r\n    {\r\n\r\n      \tvar vx = face.Sum(i => pol.Vertices[i].X) / face.Length;\r\n      \tvar vy = face.Sum(i => pol.Vertices[i].Y) / face.Length;\r\n      \tvar vz = face.Sum(i => pol.Vertices[i].Z) / face.Length;      \t\r\n\r\n      \tvar nv = sqrt(vx*vx +vy*vy +vz*vz);\r\n      \r\n      \tvx /= nv; vy /= nv; vz /=nv;\r\n      \r\n      \r\n      \tdouble[] v = null;\r\n        Vec3 p = new Vec3(vx, vy, vz);      // point on sphere (should be normalized)\r\n        Vec3 k = new Vec3(0, -sin(a), cos(a));         // north axis\r\n      \r\n      \t\r\n\t\tif(abs(p.X*k.X+ p.Y*k.Y+p.Z*k.Z) < 0.99)\r\n        {\r\n\r\n            Vec3 north = Vec3.Cross(p, Vec3.Cross(k, p)).Normalize();\r\n            Vec3 east = Vec3.Cross(k, p).Normalize();\r\n          \r\n       \t\tv = new double[]{north.X, north.Y, north.Z};\r\n        }\r\n      \r\n      \tres = res & !\r\n          (PrismStar(0.8*vx, 0.8*vy, 0.8*vz, 11*vx, 11*vy, 11*vz, 0.4, 4, 0.25, v: v) |\r\n           PrismStar(0.8*vx, 0.8*vy, 0.8*vz, 11*vx, 11*vy, 11*vz, 0.3, 4, 0.35, v: v, sa: PI/4))\r\n           ;\r\n    }    \t\r\n  \r\n    res.Transform(delegate(ref double x, ref double y, ref double z)\r\n\t{\r\n\r\n      double y1 = y * cos(a) - z * sin(a);\r\n      double z1 =y * sin(a) + z * cos(a);\r\n      y = y1; z = z1;         \r\n      \r\n    });\r\n  \r\n  return res;\r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n    var res = new IneqMesh\r\n    {\r\n        X0 = -1.1,\r\n        Y0 = -1.1,\r\n        Z0 = -1.1,\r\n        X1 = 1.1,\r\n        Y1 = 1.1,\r\n        Z1 = 1.3,\r\n        D = 0.05d,\r\n        Boxed = true,\r\n        IneqTree = Torus(0,0,1.0, 0.05, 0.15, 0,1,0) | \r\n          //Cylinder(0,0,0.85 - 0.15,0,0,1.1 - 0.15,0.25) |\r\n         StarBall() \r\n\t\t\t\t\r\n\t};\r\n \r\n  \r\n\tres.PrepareBackgroundMeshBeforeApriory = () => \r\n    {\r\n      \r\n\t\tres.RefineTetrahedralMeshNearPointRedGreen(new Point[]\r\n\t\t{ \r\n          new Point(0,0,0.9),\r\n\t\t}, 0.2d, 1);      \r\n    };\r\n  \r\n  \treturn res;\r\n}\r\n"}