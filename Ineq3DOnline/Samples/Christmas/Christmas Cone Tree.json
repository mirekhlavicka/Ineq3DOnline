{"name":"Christmas\\Christmas Cone Tree","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nprivate IneqTree Star()\r\n{\r\n    var res = Ineq3DOnline.PlatonicSolids.Polyhedron.CreateIcosahedron(0.4).ToIneqTreeStar(3.1, 0.8); \r\n\r\n    res.Transform(delegate(ref double x, ref double y, ref double z)\r\n\t{\r\n      z -= 1;\r\n      \r\n      x *= 4.0; y *= 4.0; z *= 4.0;\r\n      \r\n      double a = (PI - acos(-sqrt(5)/5))/2;\r\n\r\n      double y1 = y * cos(a) - z * sin(a);\r\n      double z1 =y * sin(a) + z * cos(a);\r\n      y = y1; z = z1;         \r\n      \r\n    });\r\n  \r\n  \treturn res;\r\n}\r\n\r\npublic static IneqTree Planes(int count, double r)\r\n{\r\n    IneqTree res = new IneqTree();\r\n\r\n    for (int i = 0; i < count; i++)\r\n    {\r\n        double x0 = r * Math.Cos(PI/10 + i * 2 * Math.PI / count);\r\n        double y0 = r * Math.Sin(PI/10 + i * 2 * Math.PI / count);\r\n        double z0 = 0;\r\n\r\n        res = res & ((x, y, z) => (x - x0) * x0 + (y - y0) * y0 + (z - z0) * z0);\r\n    }\r\n\r\n    return res;\r\n}\r\n\r\nprivate IneqTree Tree()\r\n{\r\n  var res = new IneqTree();\r\n  var b = ((# z + sqrt(8*x*x + 8*y*y)-1) & (# z - 0.95)) & !((# z + sqrt(8*x*x + 8*y*y)-0.9) & (# z-0.6));\r\n\r\n  b.Transform(delegate(ref double x, ref double y, ref double z)\r\n              {\r\n                double r = 1 + cos(20*z)/10;\r\n\r\n                x /= r;\r\n                y /= r;\r\n\r\n              });\r\n  \r\n\tb.Transform(delegate(ref double x, ref double y, ref double z) \r\n\t{\r\n      \tdouble a;\r\n       \ta = abs(x)+abs(y) > 0.0001 ? atan2(x, y) : 0;\r\n      \tdouble f = 0.75 + sin(4*a)*sin(4*a)/(8 + 3*z);// + (1-z)/6;\r\n      \r\n\t\tx /= f;\r\n      \ty /= f;\r\n    });  \r\n  \r\n  \r\n  res = res | b;\r\n  \r\n  res = res &\r\n    !PrismStar(-3,0,0.25, 3,0,0.25, 0.1, 5, 0.5, v: new double[]{0,0,1}) &\r\n  \t!PrismStar(0,-3,0.25, 0,3,0.25, 0.1, 5, 0.5, v: new double[]{0,0,1}) &\r\n\r\n    !PrismStar(-3,0,-0.35, 3,0,-0.35, 0.2, 5, 0.5, v: new double[]{0,0,1}) &\r\n  \t!PrismStar(0,-3,-0.35, 0,3,-0.35, 0.2, 5, 0.5, v: new double[]{0,0,1}) & \r\n    \r\n    !PrismStar(-3,-3,-0.05, 3,3,-0.05, 0.15, 5, 0.5, v: new double[]{0,0,1}) &\r\n  \t!PrismStar(3,-3,-0.05, -3,3,-0.05, 0.15, 5, 0.5, v: new double[]{0,0,1}) & \r\n\r\n    !PrismStar(-3,-3,0.55, 3,3,0.55, 0.05, 5, 0.5, v: new double[]{0,0,1}) &\r\n  \t!PrismStar(3,-3,0.55, -3,3,0.55, 0.05, 5, 0.5, v: new double[]{0,0,1});\r\n  \r\n  \r\n  return res;\r\n\r\n}\r\n\r\n\r\n\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{ \r\n    var res = new IneqMesh\r\n    {\r\n        X0 = -1.000054650,\r\n        Y0 = -1.0000654654,\r\n        Z0 = -0.6,\r\n        X1 = 1.00005465,\r\n        Y1 = 1.0000054654,\r\n        Z1 = 1.5,\r\n        D = 0.08d,\r\n        Boxed = true,\r\n        IneqTree = Tree() //|\r\n          //(Planes(12, 0.35d) & (#z + 0.5))\r\n          \r\n          | Star()\r\n          \r\n          /*.ToFunc(0.02)*/ //| Star()          \r\n      };\r\n  \r\n  \tres.PrepareBackgroundMeshBeforeApriory = () => \r\n    {\r\n\t\tres.RefineTetrahedralMeshNearPointRedGreen(new Point[]\r\n\t\t{ \r\n          new Point(0,0,1),\r\n\t\t}, 0.25d, 2);\r\n      \r\n      \r\n    };\r\n  \r\n  \treturn res;\r\n}\r\n"}