{"name":"Christmas\\Star Ball Light","x0":-1.0,"y0":-1.0,"z0":-1.0,"x1":1.0,"y1":1.0,"z1":1.0,"maxDivisionCount":12,"quality":false,"curvatureQuality":false,"formula":"[advanced]\r\n\r\nprivate IneqTree StarBall(bool top)\r\n{\r\n\tIneqTree res;\r\n    \r\n\tif(top)\r\n    {\r\n  \t\tres = Ball(0,0,0,1) & !Ball(0,0,0,0.9);\r\n    }\r\n  \telse\r\n    {\r\n\t\tvar d = (# z + 0.8);\r\n      \r\n        d.Transform(delegate(ref double x, ref double y, ref double z)\r\n\t\t{\r\n          double a = -(PI - acos(-sqrt(5)/5))/2;\r\n          double y1 = y * cos(a) - z * sin(a);\r\n          double z1 =y * sin(a) + z * cos(a);\r\n          y = y1; z = z1;         \r\n        });      \r\n      \r\n      \tres = Ball(0,0,0,1) & (!Ball(0,0,0,0.9) | d);\r\n    }\r\n\r\n  \tvar pol = Ineq3DOnline.PlatonicSolids.Polyhedron.CreateDodecahedron(1);\r\n  \r\n  \tforeach (var face in pol.Faces.Where((item, index) => /*index != 4 &&*/ index != 7)/*.Take(5)*/)\r\n    {\r\n\r\n      \tvar vx = face.Sum(i => pol.Vertices[i].X) / face.Length;\r\n      \tvar vy = face.Sum(i => pol.Vertices[i].Y) / face.Length;\r\n      \tvar vz = face.Sum(i => pol.Vertices[i].Z) / face.Length;      \t\r\n      \r\n      \tvar v0x = vx - pol.Vertices[face[0]].X;\r\n      \tvar v0y = vy - pol.Vertices[face[0]].Y;\r\n      \tvar v0z = vz - pol.Vertices[face[0]].Z;\r\n      \tvar nv = sqrt(v0x*v0x +v0y*v0y +v0z*v0z);\r\n      \r\n      \tres = res & !PrismStar(0.8*vx, 0.8*vy, 0.8*vz, 11*vx, 11*vy, 11*vz, 0.4, 5, 0.35, v: new double[]{v0x/nv, v0y/nv, v0z/nv}/*, sa: PI/5*/);\r\n    }    \t\r\n  \r\n    res.Transform(delegate(ref double x, ref double y, ref double z)\r\n\t{\r\n      double a = (PI - acos(-sqrt(5)/5))/2;\r\n\r\n      double y1 = y * cos(a) - z * sin(a);\r\n      double z1 =y * sin(a) + z * cos(a);\r\n      y = y1; z = z1;         \r\n      \r\n    });\r\n  \r\n  \r\n  \r\n  \tif(top)\r\n    {\r\n      \tres = res  &\r\n         !(# z - sqrt(x*x + y*y)+0.95) & !(# z + 0.25);      \r\n          res.Transform(delegate(ref double x, ref double y, ref double z)\r\n          {\r\n              z -= 0.3;      \r\n          });      \r\n    }\r\n  \telse\r\n  \t{\r\n      \tres = res  &\r\n         ((# z - sqrt(x*x + y*y)+0.95) | (# z+0.5)) &\r\n         (# -z - 0.95 );\r\n    }\r\n  \r\n  return res;\r\n}\r\n\r\npublic IneqMesh GetIneqMesh()\r\n{\r\n    var res = new IneqMesh\r\n    {\r\n        X0 = -1.1,\r\n        Y0 = -1.1,\r\n        Z0 = -1.1,\r\n        X1 = 1.1,\r\n        Y1 = 1.1,\r\n        Z1 = 1.5,\r\n        D = 0.1d,\r\n        Boxed = true,\r\n        IneqTree = //Torus(0,0,1.0, 0.05, 0.15, 0,1,0) | \r\n          //Cylinder(0,0,0.85 - 0.15,0,0,1.1 - 0.15,0.25) |\r\n         \tStarBall(false)           \r\n\t\t\t| StarBall(true) \r\n\t\t\t\t\r\n\t};\r\n \r\n  \r\n\t/*res.PrepareBackgroundMeshBeforeApriory = () => \r\n    {\r\n      \r\n\t\tres.RefineTetrahedralMeshNearPointRedGreen(new Point[]\r\n\t\t{ \r\n          new Point(0,0,0.9),\r\n\t\t}, 0.2d, 1);      \r\n    };*/\r\n  \r\n  \treturn res;\r\n}\r\n"}